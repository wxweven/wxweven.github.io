<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="FI8PcIsw2IdZu1dwbSA4PcUEtkixmT8h9bdaHPNj3f0">













  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Monda, " pingfang="" sc",="" "microsoft="" yahei",="" sans-serif:300,300italic,400,400italic,700,700italic|lobster="" two:300,300italic,400,400italic,700,700italic|monaco:300,300italic,400,400italic,700,700italic&subset="latin,latin-ext"" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Java,ThreadLocal,">








  <link rel="shortcut icon" type="image/x-icon" href="/siteimages/favicon.ico?v=5.1.1">






<meta name="description" content="想必很多朋友对ThreadLocal并不陌生，今天我们就来一起探讨下ThreadLocal实现原理和相关源码。首先，本文先介绍一下ThreadLocal以及底层结构，然后从ThreadLocal相关的API入手，详细分析ThreadLocal源码和使用时需要注意的地方，最后分析下ThreadLocal中的内存泄露问题。">
<meta name="keywords" content="Java,ThreadLocal">
<meta property="og:type" content="article">
<meta property="og:title" content="ThreadLocal源码深度解析">
<meta property="og:url" content="http://wxweven.win/2018/03/11/ThreadLocal源码深度解析/index.html">
<meta property="og:site_name" content="wxweven 梦想之家">
<meta property="og:description" content="想必很多朋友对ThreadLocal并不陌生，今天我们就来一起探讨下ThreadLocal实现原理和相关源码。首先，本文先介绍一下ThreadLocal以及底层结构，然后从ThreadLocal相关的API入手，详细分析ThreadLocal源码和使用时需要注意的地方，最后分析下ThreadLocal中的内存泄露问题。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://wxweven.win/img/15207382102972.jpg">
<meta property="og:image" content="http://wxweven.win/img/15207387415630.jpg">
<meta property="og:image" content="http://wxweven.win/img/15207500053074.png">
<meta property="og:image" content="http://wxweven.win/img/15207551785678.jpg">
<meta property="og:image" content="http://wxweven.win/img/15207685731521.jpg">
<meta property="og:image" content="http://wxweven.win/img/15207598329849.png">
<meta property="og:updated_time" content="2018-03-23T05:58:12.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ThreadLocal源码深度解析">
<meta name="twitter:description" content="想必很多朋友对ThreadLocal并不陌生，今天我们就来一起探讨下ThreadLocal实现原理和相关源码。首先，本文先介绍一下ThreadLocal以及底层结构，然后从ThreadLocal相关的API入手，详细分析ThreadLocal源码和使用时需要注意的地方，最后分析下ThreadLocal中的内存泄露问题。">
<meta name="twitter:image" content="http://wxweven.win/img/15207382102972.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://wxweven.win/2018/03/11/ThreadLocal源码深度解析/">





  <title>ThreadLocal源码深度解析 | wxweven 梦想之家</title>
  














</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wxweven 梦想之家</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术成就梦想 | 做一个有梦想的程序猿</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wxweven.win/2018/03/11/ThreadLocal源码深度解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wxweven">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/siteimages/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxweven 梦想之家">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ThreadLocal源码深度解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-11T11:01:21+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java并发/" itemprop="url" rel="index">
                    <span itemprop="name">Java并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  10,184 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  45 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<p>想必很多朋友对ThreadLocal并不陌生，今天我们就来一起探讨下ThreadLocal实现原理和相关源码。首先，本文先介绍一下ThreadLocal以及底层结构，然后从ThreadLocal相关的API入手，详细分析ThreadLocal源码和使用时需要注意的地方，最后分析下ThreadLocal中的内存泄露问题。</p>
<a id="more"></a>

<h1 id="ThreadLocal概述">1. ThreadLocal概述</h1><p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。我们首先来看下JDK中的解释：</p>
<blockquote>
<p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g.a user ID or Transaction ID).<br>Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist)</p>
</blockquote>
<p>也就是说这个类给线程提供了一个本地变量，这个变量是该线程自己拥有的。在该线程存活和ThreadLocal实例能访问的时候，保存了对这个变量副本的引用。当线程消失的时候，所有的线程本地实例都会交由GC接管。</p>
<h2 id="举个栗子">1.1. 举个栗子</h2><p>我们先来看一个简单的demo，了解下如何在代码中使用ThreadLocal：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ThreadLocal instances are typically private static fields in classes</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;List&lt;String&gt;&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setThreadLocal</span><span class="params">(List&lt;String&gt; values)</span> </span>&#123;</span><br><span class="line">        threadLocal.set(values);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        threadLocal.get().forEach(name -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> ThreadLocalDemo threadLocal = <span class="keyword">new</span> ThreadLocalDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            List&lt;String&gt; params = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">            params.add(<span class="string">"张三"</span>);</span><br><span class="line">            params.add(<span class="string">"李四"</span>);</span><br><span class="line">            params.add(<span class="string">"王五"</span>);</span><br><span class="line">            threadLocal.setThreadLocal(params);</span><br><span class="line">            threadLocal.getThreadLocal();</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                List&lt;String&gt; params = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">                params.add(<span class="string">"Chinese"</span>);</span><br><span class="line">                params.add(<span class="string">"English"</span>);</span><br><span class="line">                threadLocal.setThreadLocal(params);</span><br><span class="line">                threadLocal.getThreadLocal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span></span><br><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br><span class="line">Thread-<span class="number">1</span></span><br><span class="line">Chinese</span><br><span class="line">English</span><br></pre></td></tr></table></figure>

<p>可以，看出虽然多个线程对同一个变量进行访问，但是由于threadLocal变量由ThreadLocal 修饰，则不同的线程访问的就是该线程设置的值，这里也就体现出来ThreadLocal的作用。</p>
<p>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<h1 id="ThreadLocal-的实现">2. ThreadLocal 的实现</h1><p>假设我们要设计一个和线程绑定的变量，我们会怎么做呢？<br>很常见的一个思路就是把Thread和变量值放在一个Map中，即key为对应的Thread，value为变量值。<br>那么JDK是不是按这种方式实现的呢？答案：显然不是。我们这里先不讨论JDK为什么不用这种方案，后文会详细介绍。</p>
<h2 id="ThreadLocal内部结构">2.1. ThreadLocal内部结构</h2><p>要理解ThreadLocal的内部结构，需要弄清楚以下三个关键的类：</p>
<ul>
<li>Thread</li>
<li>ThreadLocal</li>
<li>ThreadLocalMap</li>
</ul>
<p>他们之间的关系如下图：<br><img src="/img/15207382102972.jpg" alt=""></p>
<p>java.lang.Thread 内有个 ThreadLocalMap ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap 存储了所有跟该 Thread 绑定的 ThreadLocal 对象到该 ThreadLocal 对象对应 Value 的映射。每次在读取一个 ThreadLocal 对象的值的时候，就是通过 ThreadLocalMap 来查看 ThreadLocal 对象对应的值是什么。因为每个 Thread 都有自己的 ThreadLocalMap，所以同一个 ThreadLocal 对象在不同的 Thread 里能对应不同的 Value。从而实现 ThreadLocal 的功能。</p>
<p>ThreadLocalMap，从字面意义上来看，它是一个Map，大家可以类比下Java中常见的HashMap，在基本原理以及使用方式上，两者比较类似。</p>
<p>ThreadLocalMap在实现方式上，是通过数组实现 Map 功能的。数组的元素是 Entry，是个装有 Key Value 的对象。Key 是个弱引用，所以上图用虚线表示，指向一个 ThreadLocal 对象，Value 是强引用指向跟该 ThreadLocal 对象绑定的 Value 值。</p>
<p>再看一张网络上的图片，应该可以更好的理解，如下图：<br><img src="/img/15207387415630.jpg" alt=""></p>
<h2 id="ThreadLocal-API">2.2. ThreadLocal API</h2><p>下面将详细分析ThreadLocal的源码，我们从ThreadLocal提供的API入手。</p>
<h3 id="ThreadLocal-的-set-方法">2.2.1. ThreadLocal 的 set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获得当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread(); </span><br><span class="line">    <span class="comment">// 2. 拿到当前线程对应的ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 3. 判断map是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>set</code>方法，将此线程局部变量的当前线程副本中的值设置为指定值。</p>
</blockquote>
<p>我们来详细看源码。首先，获得当前线程，然后根据当前线程去获取对应的ThreadLocalMap。那我们继续看 <code>getMap(t)</code> 又做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，就是返回当前线程的threadLocals变量，前面提到过，这个变量就是当前线程中的ThreadLocalMap。</p>
<p>我们接着set方法往下看。首先会判断map是否为空，如果不为空，那么调用ThreadLocalMap的set方法，设置值；如果为空，则创建一个ThreadLocalMap。</p>
<p>假设我们是第一次调用set方法，那么map肯定为空，所以会调用createMap方法，我们接着看createMap方法又做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，createMap方法创建了一个新的ThreadLocalMap并赋初值，将我们的传入的值保存到ThreadLocalMap中。ThreadLocalMap的构造函数，我们将在下文详细介绍。<strong>第一次调用</strong>set方法的过程到这里基本上就算是结束了。</p>
<p>我们接着回到set代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">    map.set(<span class="keyword">this</span>, value);</span><br></pre></td></tr></table></figure>

<p>可以看到，如果map不为空，会调用map的set方法，将key（也就是当前ThreadLocal对象）、value（set方法传入的值）保存到ThreadLocalMap中。有关于ThreadLocalMap的set方法，也将在下文中介绍。</p>
<p>到此，ThreadLocal的set方法，全部分析完毕。这里做个总结：</p>
<ol>
<li>获取当前线程；</li>
<li>拿到当前线程的ThreadLocalMap，如果不为空，转3；否则转4；</li>
<li>map不为空，调用ThreadLocalMap的set方法，将当前ThreadLocal对象和传入的value值，保存到map中，方法结束。</li>
<li>map为空，创建一个ThreadLocalMap，赋值给当前线程的<code>threadLocals</code>变量（也就是当前线程绑定的ThreadLocalMap），然后将当前ThreadLocal对象和传入的value值，保存到map中，方法结束。</li>
</ol>
<h3 id="ThreadLocal的get方法">2.2.2. ThreadLocal的get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 2. 拿到当前线程对应的ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 3. 判断map是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>get</code>方法，返回此线程局部变量的当前线程副本中的值。如果这是线程第一次调用该方法，则创建并初始化此副本。</p>
</blockquote>
<p>我们直接看源码。可以看到，get方法的前3步骤与set方法相同，不再赘述。<br>我们这里看关键的第三步，判断map是否为null。我们知道，初始情况下，Thread对象中的map变量为null：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>而在上面的set方法分析中可以知道，只要调用过set方法后，map必然不为空。所以调用get方法时，如果事先已经调用过set方法赋值，那么这里map肯定不为null。而如果没有事先调用set，那么直接调用get方法，则map为null。</p>
<p>我们首先来看map不为null的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T result = (T)e.value;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，跟set方法类似，也是交给ThreadLocalMap去处理：调用map的getEntry方法（ThreadLocalMap的处理方法，我们统一在后文中介绍）。拿到对应的值后返回，get方法结束。</p>
<p>如果map为null，我们来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> setInitialValue();</span><br></pre></td></tr></table></figure>

<p>返回的是 setInitialValue 方法的值。那么我们接着看这个setInitialValue方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Variant of set() to establish initialValue. Used instead</span></span><br><span class="line"><span class="comment"> * of set() in case user has overridden the set() method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是不是和set方法十分类似？实际上，作者也在注释里写得很清楚了：</p>
<blockquote>
<p>Variant of set() to establish initialValue</p>
</blockquote>
<p>这个方法就是set方法的一个变种，唯一的区别是：set方法中的value是传入的，而这个方法的value是调用 initialValue 方法获得的。没错，我们接下来就是要去看 initialValue 方法干了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the current thread's "initial value" for this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  This method will be invoked the first</span></span><br><span class="line"><span class="comment"> * time a thread accesses the variable with the &#123;<span class="doctag">@link</span> #get&#125;</span></span><br><span class="line"><span class="comment"> * method, unless the thread previously invoked the &#123;<span class="doctag">@link</span> #set&#125;</span></span><br><span class="line"><span class="comment"> * method, in which case the &#123;<span class="doctag">@code</span> initialValue&#125; method will not</span></span><br><span class="line"><span class="comment"> * be invoked for the thread.  Normally, this method is invoked at</span></span><br><span class="line"><span class="comment"> * most once per thread, but it may be invoked again in case of</span></span><br><span class="line"><span class="comment"> * subsequent invocations of &#123;<span class="doctag">@link</span> #remove&#125; followed by &#123;<span class="doctag">@link</span> #get&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation simply returns &#123;<span class="doctag">@code</span> null&#125;; if the</span></span><br><span class="line"><span class="comment"> * programmer desires thread-local variables to have an initial</span></span><br><span class="line"><span class="comment"> * value other than &#123;<span class="doctag">@code</span> null&#125;, &#123;<span class="doctag">@code</span> ThreadLocal&#125; must be</span></span><br><span class="line"><span class="comment"> * subclassed, and this method overridden.  Typically, an</span></span><br><span class="line"><span class="comment"> * anonymous inner class will be used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value for this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法比较特殊：</p>
<ul>
<li>直接返回null</li>
<li>方法声明为protected</li>
<li>注释比方法本身更有内容</li>
</ul>
<p>作者的注释写了一大堆，其实好好看注释就能明白这个方法的作用了。简单总结下：</p>
<blockquote>
<p>这个方法用于在第一次调用get方法而事先没有调用set方法时返回初始值，默认情况下，该初始值为null。如果用户不想得到默认的null，那么应该用ThreadLocal的子类并重写该方法，通常使用一个匿名内部类来实现。</p>
</blockquote>
<p>所以也就不难理解为什么这个方法是protected，通常来说，在Java中，protected声明的方法，都是建议子类来重写的方法。</p>
<p>假设使用ThreadLocal时，没有用子类来重写initialValue方法，也没有在调用get之前先调用set方法，那么get方法默认得到的就是null。这一点需要注意，如果不清楚这一点，很容易就会产生NPE。</p>
<p>get方法到这里也就结束了，总结下：</p>
<ol>
<li>获取当前线程；</li>
<li>拿到当前线程的ThreadLocalMap，如果不为空，转3；否则转4；</li>
<li>map不为空，调用ThreadLocalMap的getEntry方法，将之前通过set方法保存进去的Entry拿出来，返回对应的值，方法结束。</li>
<li>map为空，调用setInitialValue，该方法类似于set方法，只不过value值是初始值，初始值要么为null，要么是子类重写的初始值。返回初始值，方法结束。</li>
</ol>
<h3 id="ThreadLocal的remove方法">2.2.3. ThreadLocal的remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the current thread's value for this thread-local</span></span><br><span class="line"><span class="comment"> * variable.  If this thread-local variable is subsequently</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span></span><br><span class="line"><span class="comment"> * reinitialized by invoking its &#123;<span class="doctag">@link</span> #initialValue&#125; method,</span></span><br><span class="line"><span class="comment"> * unless its value is &#123;<span class="doctag">@linkplain</span> #set set&#125; by the current thread</span></span><br><span class="line"><span class="comment"> * in the interim.  This may result in multiple invocations of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> initialValue&#125; method in the current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">     <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">         m.remove(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>remove方法，移除此线程局部变量的值。这可能有助于减少线程局部变量的存储需求。如果再次访问此线程局部变量，那么在默认情况下它将拥有其 initialValue。</p>
</blockquote>
<p>我们直接看源码。同样，也是先获得与当前线程绑定的ThreadLocalMap，如果map不为空，将删除操作委托给map处理。</p>
<p>remove方法的作用很关键，它能够有效避免内存泄露，这个话题我们将在后文中讨论到。</p>
<h1 id="核心的ThreadLocalMap">3. 核心的ThreadLocalMap</h1><p>从上文的讨论中，我们发现，不管是ThreadLocal的底层实现结构，还是ThreadLocal的API中，最核心的就是这个<code>ThreadLocalMap</code>。</p>
<p>下面我们就来好好分析下这个ThreadLocalMap。</p>
<h2 id="Hash冲突处理">3.1. Hash冲突处理</h2><p>在详细讲解ThreadLocalMap之前，我们先要了解ThreadLocalMap的Hash冲突处理，因为这是整个ThreadLocalMap最核心的地方，理解了这个，ThreadLocalMap其他的内容也就比较好理解了。</p>
<p>首先我们回顾下Java中的HashMap，我们知道HashMap的实现方式是* 数组 + 链表*，其中数组用于Hash桶定位，链表用于解决Hash冲突。</p>
<p>ThreadLocalMap，本质上来讲，也是一个Map，也用到了Hash算法，那么它在实现上与HashMap有什么区别呢？这里先把结论给出来：</p>
<blockquote>
<p>Hash冲突的处理方式不一样，HashMap使用 <strong><em>链地址法</em></strong> 来解决Hash冲突，而ThreadLocalMap使用 <strong><em>开放地址法</em></strong> 来解决Hash冲突。</p>
</blockquote>
<p>每一个 ThreadLocal 对象都有一个 threadLocalHashCode，在将 ThreadLocal 对象及其对应 Value 放入 ThreadLocalMap 时，先根据 threadLocalHashCode 和 ThreadLocalMap 内数组大小用类似于 threadLocalHashCode % ThreadLocalMap.length() 的方法计算出来该 threadLocalHashCode 对应的哪一个 Slot 的 index，再构造 Entry 放入该 index 指向的 ThreadLocalMap 的 Slot 中。</p>
<p>因为 ThreadLocalMap 内数组大小有限，类似于 <code>threadLocalHashCode % ThreadLocalMap.length()</code> 计算 index 的方法可能出现两个不同的 ThreadLocal 对象带着两个不同的 threadLocalHashCode 但被 Hash 到同一个 Slot 的情况（即发生Hash冲突），如下图 ThreadLocalA ThreadLocalB ThreadLocalC 都具有相同的 threadLocalHashCode，在插入 ThreadLocalC 时，根据其 threadLocalHashCode 先被 Hash 到 ThreadLocalA 的 Slot，发现 Slot 不为空，于是 <code>index + 1</code> 再判断临近的已经存了 ThreadLocalB 的 Slot 是否为空，不为空则继续 <code>index + 1</code> 直到找到一个空的 Slot 将 ThreadLocalC 存入。</p>
<p><img src="/img/15207500053074.png" alt=""></p>
<p>也就是说，ThreadLocalMap发生Hash冲突时，会顺着当前Hash桶往下找（index + 1），直到找到一个为空的桶，然后将Entry放入。</p>
<p>这种碰撞处理方式也就导致:</p>
<blockquote>
<p>每个 ThreadLocal 对象的 threadLocalHashCode 不能挨得太近，不然冲突会很多。</p>
</blockquote>
<p>其计算方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode.getAndAdd(<span class="number">0x61c88647</span>)</span><br></pre></td></tr></table></figure>

<p>0x61c88647 是个很神奇的数字，据说是来自斐波那契散列，用这个数字，产生Hash冲突的概率较低。</p>
<p>ThreadLocalMap 一定不能完全装满，内置的数组一定要比实际存入的 ThreadLocal 对象至少大 1。事实上 ThreadLocalMap 的 Load Factor 是 2/3，超过之后会 rehash 并扩容。不能完全装满的原因是比如还是上面那张图，要获取一个 ThreadLocal 对象对应的 Value，并且这个目标 ThreadLocal 没有存入该 ThreadLocalMap，它的 threadLocalHashCode 刚好也 Hash 到了 ThreadLocalA 对象所在的 Slot，获取的时候先判断目标 ThreadLocal 是不是等于 ThreadLocalA，不是的话再判断是不是等于 ThreadLocalB，依次类推直到获取到一个空 Slot 从而才能知道该 ThreadLocal 没有存储在当前 ThreadLocalMap 中。如果 ThreadLocalMap 完全装满，就不能依赖这个 Slot 是否为空的判断了；</p>
<h2 id="ThreadLocalMap-API">3.2. ThreadLocalMap API</h2><p>讲完了ThreadLocalMap最核心的Hash冲突处理后，我们来看看相关的API。</p>
<p>从上文分析ThreadLocal的API过程中，我们发现，与ThreadLocal相关的的API有：</p>
<ul>
<li>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)</li>
<li>set(ThreadLocal&lt;?&gt; key, Object value)</li>
<li>getEntry(ThreadLocal&lt;?&gt; key)</li>
<li>remove(ThreadLocal&lt;?&gt; key)</li>
</ul>
<p>下面将详细介绍这些API以及相关的源码。</p>
<h3 id="ThreadLocalMap构造函数">3.2.1. ThreadLocalMap构造函数</h3><p>在前面分析ThreadLocal的set方法中，我们知道，如果当前Thread对应的ThreadLocalMap为null，则会调用createMap方法创建ThreadLocalMap：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即调用了ThreadLocalMap的构造函数，我们来看看构造函数源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment"> * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment"> * one when we have at least one entry to put in it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，注释里面说的很明白：创建一个新的map，并将firstKey、firstValue存入map。</p>
<p>我们看这里的代码，是不是跟HashMap很类似？包括Entry数组table、Hash桶定位过程中的按位与。<br>这里我们需要特别的关注下Entry对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，Entry类继承了WeakReference，即弱引用。本文一开始就提到，ThreadLocalMap中的key是弱引用，其内部实现就体现在这里。</p>
<h3 id="ThreadLocalMap的set方法">3.2.2. ThreadLocalMap的set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the value associated with key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 1. 定位Hash桶位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从当前桶位置往下遍历</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        </span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 如果key相同，替换掉原来的value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 如果当前桶位置key为null，特殊处理：替换并清除过期Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 找到一个为null的桶，将传入的Entry放入当前桶</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 没有清理出可用的桶而且容量超过阈值，重新Hash</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set方法，作用很明显，跟HashMap的put方法一样，就是将&lt;key, value&gt;键值对放入map。当然，考虑到会有Hash冲突，所以需要特殊处理（处理方式前文已经介绍）。</p>
<p>详细过程已经在源码中附加了注释，其中的『注释4』（当前位置key为null）和『注释6』是跟ThreadLocal的内存泄露相关的，我们将在『ThreadLocal的内存泄露』章节介绍到。</p>
<h3 id="ThreadLocalMap的getEntry方法">3.2.3. ThreadLocalMap的getEntry方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the entry associated with key.  This method</span></span><br><span class="line"><span class="comment"> * itself handles only the fast path: a direct hit of existing</span></span><br><span class="line"><span class="comment"> * key. It otherwise relays to getEntryAfterMiss.  This is</span></span><br><span class="line"><span class="comment"> * designed to maximize performance for direct hits, in part</span></span><br><span class="line"><span class="comment"> * by making this method readily inlinable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 定位Hash桶位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 获取当前桶位置的Entry</span></span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 如果Entry不为null且可以相同，说明Hash命中，返回对应的值即可</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 未命中，特殊处理</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get方法的作用，也无需多说，跟HashMap的get方法一样，根据key去找value。同样，考虑到Hash冲突，会有未命中的情况，需要做特殊处理，即调用getEntryAfterMiss方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Version of getEntry method for use when key is not found in</span></span><br><span class="line"><span class="comment"> * its direct hash slot.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  i the table index for key's hash code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  e the entry at table[i]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 从当前位置往下找，这个原因在Hash冲突处理章节已经介绍过：</span></span><br><span class="line">    <span class="comment">// 插入时，如果当前位置已经有元素，则往下找一个位置，看是否为null，</span></span><br><span class="line">    <span class="comment">// 如此反复，直到找到一个为null的位置，把Entry放入该位置</span></span><br><span class="line">    <span class="comment">// 所以，查找的时候，也是一样的逻辑，如果根据key算出来的Hash值位置上，不是当前Entry，</span></span><br><span class="line">    <span class="comment">// 那么就顺着数组往下找</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 2. 如果key相同，说明找到，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 3. 如果当前位置key为null，特殊处理：清除过期的Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 继续找数组的下一个位置</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后还是没有找到，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，这里需要特别注意的是『注释3』：当前数组位置key为null的情况，也是跟内存泄露相关的，『ThreadLocal的内存泄露』章节介绍到。</p>
<h3 id="ThreadLocalMap的remove方法">3.2.4. ThreadLocalMap的remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the entry for key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 定位Hash桶位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 遍历找出key对应的Entry，</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 3. 找到对应的Entry后，清理该Entry的弱引用</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// 4. 特殊处理：清除过期的Entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>remove方法，根据key去删除map中的元素。这一过程中的特殊处理，也是跟内存泄露相关，会在内存泄露章节介绍。</p>
<h1 id="ThreadLocal的内存泄露">4. ThreadLocal的内存泄露</h1><h2 id="内存泄露原理分析">4.1. 内存泄露原理分析</h2><p>我们再回过头来看看ThreadLocal的底层实现：<br><img src="/img/15207551785678.jpg" alt=""></p>
<p>在 ThreadLocal 的生命周期中，都存在这些引用。如下图：实线代表强引用，虚线代表弱引用。<br><img src="/img/15207685731521.jpg" alt=""></p>
<p>ThreadLocal 的实现是这样的：每个 Thread 维护一个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object。</p>
<p>也就是说 ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value。值得注意的是图中的虚线，表示 ThreadLocalMap 是使用 ThreadLocal 的弱引用作为 Key 的，弱引用的对象在 GC 时会被回收。</p>
<blockquote>
<p>还记得文章一开始提出的ThreadLocal设计方案问题吗？我们设想的一种方案是：在ThreadLocal当中维护一个map，key为Thread，value为值。这和JDK采用的方案有什么差别呢，JDK为什么要这样做？话说在jdk1.3之前就是用这种方式做的，但是之后就改成了现在的这种做法。<br>这样做法的优点之一是，value放在了线程当中，随着线程的生命周期生存，线程死亡，value回收。之二是性能提高了，想想一下在有很多线程的应用中，如果按照之前的做法，map该多大？性能应该会比较低，而换成后者这种方法，map的大小变得比较小，和Threadlocal的数量相同（有多少个ThreadLocal，线程当中的map实际存储的就有多少个）。</p>
</blockquote>
<p>ThreadLocalMap 使用 ThreadLocal 的弱引用作为 key，如果一个 ThreadLocal 没有外部强引用来引用它，那么系统 GC 的时候，这个 ThreadLocal 势必会被回收，这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry，就没有办法访问这些 key 为 null 的 Entry 的 value，如果当前线程再迟迟不结束的话（典型情况就是线程池方式，线程并真正不结束，只是归还到线程池中），这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链：</p>
<blockquote>
<p>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p>
</blockquote>
<p>导致value永远无法回收，造成内存泄漏。</p>
<p>总的来说就是，ThreadLocal 里面使用了一个存在弱引用的 map，map 的类型是ThreadLocal.ThreadLocalMap. Map中的 key 为一个 threadlocal 实例。这个 Map 的确使用了弱引用，不过弱引用只是针对 key。每个 key 都弱引用指向 threadlocal。 当把 threadlocal 实例置为 null 以后，没有任何强引用指向 threadlocal 实例，所以 threadlocal 将会被 gc 回收。</p>
<p>但是，我们的 value 却不能回收，而且这块 value 无法被访问到了（因为key被回收了），所以存在着内存泄露。因为存在一条从current thread连接过来的强引用。只有当前thread结束以后，current thread就不会存在栈中，强引用断开，Current Thread、Map value 将全部被 GC 回收。</p>
<h2 id="内存泄露问题解决">4.2. 内存泄露问题解决</h2><p>上文已经详细介绍了ThreadLocal中内存泄露的原因。那么是不是说明我们使用ThreadLocal就一定会有内存泄露问题呢？答案是否定的。否则的话，那这就是JDK的一个重大bug，ThreadLocal也就没有存在的必要了。</p>
<p>那么JDK是如何去解决这个内存泄露问题的呢？不知道大家还记不记得，在上文分析ThreadLocalMap API源码的过程中，特意留了几个略带思考的问题：</p>
<blockquote>
<p>在ThreadLocalMap的set、getEntry、remove方法中，都提到了『特殊处理』</p>
</blockquote>
<p>这个『特殊处理』就是为了解决内存泄露问题，它会清理掉不再被使用的Entry、value对象。</p>
<h3 id="ThreadLocalMap的清理">4.2.1. ThreadLocalMap的清理</h3><p>在介绍内存泄露问题解决方案之前，我们先来看一个比较重要的基础：ThreadLocalMap的清理。</p>
<p>ThreadLocalMap特殊的Hash冲突处理方式，导致了：</p>
<blockquote>
<p>清理 ThreadLocalMap 时候要保证将一个 index 指向的 Slot 清理之后，需要连带着将挨着该 index 的非空 Slot 内的 ThreadLocal 对象全部 Rehash 一遍。</p>
</blockquote>
<p>因为这些 Slot 内存储的 ThreadLocal 对象和 index 指向的 Slot 内存储的 ThreadLocal 对象都 Hash 到了同一个 ThreadLocalMap 内的 Slot，如果把开头 Slot 清理后面的不 Rehash 就无法找到他们了（这一过程详见ThreadLocalMap的get方法）。</p>
<p>JDK源码中，执行清理 ThreadLocalMap 的操作的有三个地方：</p>
<ul>
<li>主动调用 ThreadLocalMap 内的 remove</li>
<li>set 值到 ThreadLocalMap 时调用 replaceStaleEntry 和 cleanSomeSlots</li>
<li>getEntry 时如果发现 Key 找不到会执行 expungeStaleEntry</li>
</ul>
<p>下面将详细介绍这三种清理机制。</p>
<h3 id="ThreadLocalMap-的-remove">4.2.2. ThreadLocalMap 的 remove</h3><p>同样，我们还是来看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the entry for key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 定位Hash桶位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 遍历找出key对应的Entry，</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 3. 找到对应的Entry后，清理该Entry的弱引用</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// 4. 特殊处理：清除过期的Entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的清理工作就是在 <code>expungeStaleEntry</code> 方法中执行的。我们来看看这个神秘的<code>expungeStaleEntry</code> 方法。</p>
<h3 id="expungeStaleEntry源码解析">4.2.3. expungeStaleEntry源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class="line"><span class="comment"> * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class="line"><span class="comment"> * any other stale entries encountered before the trailing null.  See</span></span><br><span class="line"><span class="comment"> * Knuth, Section 6.4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> staleSlot index of slot known to have null key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the next null slot after staleSlot</span></span><br><span class="line"><span class="comment"> * (all between staleSlot and this slot will have been checked</span></span><br><span class="line"><span class="comment"> * for expunging).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 清理当前slot的Entry</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 从当前位置开始往下遍历，直到找到为null的slot</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// key为null，该Entry已经无法被访问，清除改Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// key不为null，需要rehash，原因在『ThreadLocalMap的清理』小节讲过</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果h==i，说明当前ThreadLocal与清理开始的ThreadLocal不是同一个run，不需要处理</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ThreadLocal 代码中，被 Hash 到同一个 Slot 的所有 ThreadLocal 对象称为一个 run，他们在 ThreadLocalMap 数组内紧挨着存储。</p>
<p>expungeStaleEntry的工作是传入一个 Slot 的 index，将该 index 指向的 Slot 清理，并且将该 index 之后同一个 run 内的所有 Slot 都检查一遍，发现 Slot 指向的 ThreadLocal 被 GC 则也清理该 Slot，没 GC 就将该 ThreadLocal 对象重新 rehash 到 ThreadLocalMap 的其它 Slot 上。最终会返回目标 index 所在 run 的终点序号，也即一个 run 末尾的空 Slot 的 index 值。</p>
<h3 id="ThreadLocalMap-的-set">4.2.4. ThreadLocalMap 的 set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the value associated with key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 1. 定位Hash桶位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从当前桶位置往下遍历</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        </span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 如果key相同，替换掉原来的value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 如果当前桶位置key为null，特殊处理：替换并清除过期Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 找到一个为null的桶，将传入的Entry放入当前桶</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 没有清理出可用的桶而且容量超过阈值，重新Hash</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set 操作是传入一个 ThreadLocal 对象和待和其绑定的 value，将这个 ThreadLocal 和 value 存入 ThreadLocalMap 中。存的时候也是需要先对 ThreadLocal 对象做 Hash 找到其在 ThreadLocalMap 中的 Slot，如果 Slot 被占用，会有三种情况：</p>
<ul>
<li>Slot 内存储的 ThreadLocal 对象就是当前待存储的 ThreadLocal 对象，此时只需要用新 Value 替换原来的 Value 就结束了；</li>
<li>Slot 内存储的 ThreadLocal 不是当前待存储的 ThreadLocal 对象，并且之前存的 ThreadLocal 对象已经被 GC 掉，Slot 内 Entry 的 WeakReference 读取后返回空，这种情况下需要将原来 Entry 废弃并建立新的 Entry 指向这个新的 ThreadLocal 对象，存入当前的 Slot。这个替换过程使用的是 <code>replaceStaleEntry</code> 方法；</li>
<li>如果不是上面两种情况，则需要继续查看紧挨着的 Slot 直到遇到空 Slot。找到空 Slot 说明我们找到一个空位置，则创建全新的 Entry 指向当前 ThreadLocal 对象，存入这个找到的空 Slot；</li>
</ul>
<p>如果是上面第三种情况，添加完新的 Entry 之后，还会执行一次 <code>cleanSomeSlots</code> 方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Heuristically scan some cells looking for stale entries.</span></span><br><span class="line"><span class="comment"> * This is invoked when either a new element is added, or</span></span><br><span class="line"><span class="comment"> * another stale one has been expunged. It performs a</span></span><br><span class="line"><span class="comment"> * logarithmic number of scans, as a balance between no</span></span><br><span class="line"><span class="comment"> * scanning (fast but retains garbage) and a number of scans</span></span><br><span class="line"><span class="comment"> * proportional to number of elements, that would find all</span></span><br><span class="line"><span class="comment"> * garbage but would cause some insertions to take O(n) time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i a position known NOT to hold a stale entry. The</span></span><br><span class="line"><span class="comment"> * scan starts at the element after i.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n scan control: &#123;<span class="doctag">@code</span> log2(n)&#125; cells are scanned,</span></span><br><span class="line"><span class="comment"> * unless a stale entry is found, in which case</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> log2(table.length)-1&#125; additional cells are scanned.</span></span><br><span class="line"><span class="comment"> * When called from insertions, this parameter is the number</span></span><br><span class="line"><span class="comment"> * of elements, but when from replaceStaleEntry, it is the</span></span><br><span class="line"><span class="comment"> * table length. (Note: all this could be changed to be either</span></span><br><span class="line"><span class="comment"> * more or less aggressive by weighting n instead of just</span></span><br><span class="line"><span class="comment"> * using straight log n. But this version is simple, fast, and</span></span><br><span class="line"><span class="comment"> * seems to work well.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if any stale entries have been removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="comment">// 1. 清理当前已经失效的Entry</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 2. 清理过期的Entry，前文讲过</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是在当前新添加的 Entry 所在 Slot 之后，连续的找 log N 个 Slot，判断这些 Slot 内存储的 Entry 是否指向一个已经被 GC 的 ThreadLocal 对象，是的话就对这个 Slot 执行 <code>expungeStaleEntry</code>，做清理。其中 N 是当前 ThreadLocalMap 内存储的 ThreadLocal 对象总数。</p>
<p>对于上面第 2 种情况中使用的 <code>replaceStaleEntry</code> 其实现还比较复杂，拿下图来说：<br><img src="/img/15207598329849.png" alt=""></p>
<p>假设当前要存的是 ThreadLocalB，并且 ThreadLocalA B C 在这个 ThreadLocalMap 都具有相同的 Hash 值，从而都 Hash 到同一个 Slot 即现在 ThreadLocalA 所在的 Slot。也正因为碰撞所以 ThreadLocalB C 都是紧挨着 ThreadLocalA 存储的。3 号位 Slot 指向 null 表示它本来是存一个 ThreadLocal 对象的，但这个对象被 GC 了，所以按照上面对 set 方法的描述，再次 set ThreadLocalB 的时候发现 3 号位是 null 就会执行 replaceStaleEntry，希望将 3 号位 replace 为 ThreadLocalB 并绑定上最新的 Value。</p>
<p>但是因为我们只检查到 3 号位，我们只能确认 2 3 两个位置没有 ThreadLocalB 对象，但 ThreadLocalB 对象可能存在于 3 号位之后的 Slot 中，所以直接将 ThreadLocalB 存入 3 号位是不行的，需要从 3 号位向后遍历着查找一下看看 3 号位之后还有没有 ThreadLocalB 对象了，如上图所示 3 号位之后还确实是有 ThreadLocalB 对象，并且因为发现 3 号位原来的 ThreadLocal 对象已经被 GC，所以 replaceStaleEntry 需要将 4 号位的 ThreadLocalB 挪到 3 号位，并且将该 ThreadLocalB 对象绑定上新的 Value。交换之后 4 号位我们知道是需要被清理的，所以会调用 <code>expungeStaleEntry</code> 将该位置的 Slot 清理，并且将 4 号位之后的 Slot 都进行 rehash。</p>
<p>当前面 expungeStaleEntry 执行之后，还是会调用 cleanSomeSlots 来探测当前 run 之后，也即 6 号位 Slot 之后 log N 个 Slot 看看有没有被 GC 掉的 ThreadLocal，有的话就用 expungeStaleEntry 做清理。</p>
<p>需要注意的是如果在 4 号位找到 ThreadLocalB，则 4 号位之后是不可能再有 ThreadLocalB 的，所以找到 4 号位做完交换和更新 Value 之后不需要从 4 号位再往后找有没有 ThreadLocalB 了。</p>
<p>除了上面说的这一大堆之外，replaceStaleEntry 实际还会检查同一个 run 内 3 号位之前的 Slot，看看这些 Slot 的 ThreadLocal 对象有没有被 GC 掉，虽然这些 Slot 在 replaceStaleEntry 执行之前，在 set 方法内已经检查过一次。从 replaceStaleEntry 内注释来看主要原因是想避免连续的 rehash。我个人推测，主要是因为 set 操作三种情况中，最耗时的就是第二种需要执行 replaceStaleEntry 的情况，无论是直接找到被更新的 ThreadLocal 对象直接更新绑定的 Value 还是在一个 run 内没有发现被 GC 的 ThreadLocal 对象直接将新的 ThreadLocal 存在一个 run 的末尾的空 Slot 内，耗时都是比较小的，而需要执行 replaceStaleEntry 时因为清理一个 Slot 需要将后续所有 Slot 全部 Rehash 所以耗时最大，所以要尽可能的避免 replaceStaleEntry 的执行。而 GC 是任意时刻都可能执行的，虽然 set 操作内检查过上图 2 号位，但是 GC 过后可能 2 号位的 ThreadLocalA 也被 GC 掉了，所以再次检查一下能更好的避免 replaceStaleEntry 的执行。</p>
<p>如果发现 3 号位之前有 ThreadLocal 对象被 GC，则在替换完 3 号位后，会直接从 3 号位之前这个被 GC 的 ThreadLocal 对象所在 Slot 开始，完整的执行一遍 expungeStaleEntry，全部执行完后相当于是从 expungeStaleEntry 执行开始的 Slot 到一个 run 的末尾所有被 GC 掉的 ThreadLocal 都会被清理。</p>
<p>replaceStaleEntry方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replace a stale entry encountered during a set operation</span></span><br><span class="line"><span class="comment"> * with an entry for the specified key.  The value passed in</span></span><br><span class="line"><span class="comment"> * the value parameter is stored in the entry, whether or not</span></span><br><span class="line"><span class="comment"> * an entry already exists for the specified key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As a side effect, this method expunges all stale entries in the</span></span><br><span class="line"><span class="comment"> * "run" containing the stale entry.  (A run is a sequence of entries</span></span><br><span class="line"><span class="comment"> * between two null slots.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  value the value to be associated with key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  staleSlot index of the first stale entry encountered while</span></span><br><span class="line"><span class="comment"> *         searching for key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn't find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocalMap的getEntry">4.2.5. ThreadLocalMap的getEntry</h3><p>ThreadLocalMap的getEntry方法，在未命中时，会调用getEntryAfterMiss，该方法也会做一次清理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Version of getEntry method for use when key is not found in</span></span><br><span class="line"><span class="comment"> * its direct hash slot.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  i the table index for key's hash code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  e the entry at table[i]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 从当前位置往下找，这个原因在Hash冲突处理章节已经介绍过：</span></span><br><span class="line">    <span class="comment">// 插入时，如果当前位置已经有元素，则往下找一个位置，看是否为null，</span></span><br><span class="line">    <span class="comment">// 如此反复，直到找到一个为null的位置，把Entry放入该位置</span></span><br><span class="line">    <span class="comment">// 所以，查找的时候，也是一样的逻辑，如果根据key算出来的Hash值位置上，不是当前Entry，</span></span><br><span class="line">    <span class="comment">// 那么就顺着数组往下找</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 2. 如果key相同，说明找到，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 3. 如果当前位置key为null，特殊处理：清除过期的Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 继续找数组的下一个位置</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后还是没有找到，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在key为null时，会调用expungeStaleEntry方法进行清理，前文已经分析过expungeStaleEntry过程，不再赘述。</p>
<h3 id="内存泄露问题小结">4.2.6. 内存泄露问题小结</h3><p>到此为止，ThreadLocalMap的三种清理全部讲述完毕，分别是：</p>
<ul>
<li>主动调用 ThreadLocalMap 内的 remove</li>
<li>set 值到 ThreadLocalMap 时调用 replaceStaleEntry 和 cleanSomeSlots</li>
<li>getEntry 时如果发现 Key 找不到会执行 expungeStaleEntry</li>
</ul>
<p>所以，大多数情况下，使用ThreadLocal不会产生内存泄露问题，因为在后续的set、get过程中，ThreadLocal会自动进行内存清理。</p>
<p>ThreadLocal 自动清理机制需要依赖于用户调用 ThreadLocalMap 下的 set 和 getEntry 两个方法，即ThreadLocal的set、get方法，如果一个 ThreadLocal 对象已经被 GC，用户不再向同一个 Thread 绑定新的 ThreadLocal 对象，也再不读取 Thread 上的其它 ThreadLocal 对象，就无法触发 ThreadLocalMap 的 set 和 getEntry 方法，导致 ThreadLocal 内存储的 Value 对象永久驻留内存。</p>
<p>所以即使ThreadLocal有自动内存清理机制，依然建议使用remove方法来手动清理内存。使用完ThreadLocal变量后，手动remove是个非常好的习惯！</p>
<h1 id="思考题">5. 思考题</h1><p>啰里啰嗦写了将近1万字，也不知道列位看官有多少收获，这里列几个思考题供列位看官思考下：</p>
<ol>
<li>既然ThreadLocalMap的key用弱引用来帮助GC，那么value是否也可以使用弱引用？这样不就不存在内存泄露问题了吗？</li>
<li>ThreadLocalMap为什么要采用开放地址法，而不是像HashMap那样，采用链地址法（即数组+链表）？</li>
</ol>
<h1 id="参考">6. 参考</h1><ul>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3920407.html</a></li>
<li><a href="http://gitbook.cn/gitchat/column/5a24fb14e3a13b7fc5933a44/topic/5a27f1b76982903f1c8c6550" target="_blank" rel="noopener">http://gitbook.cn/gitchat/column/5a24fb14e3a13b7fc5933a44/topic/5a27f1b76982903f1c8c6550</a></li>
<li><a href="http://gitbook.cn/gitchat/column/5a24fb14e3a13b7fc5933a44/topic/5a27f17d6982903f1c8c6532" target="_blank" rel="noopener">http://gitbook.cn/gitchat/column/5a24fb14e3a13b7fc5933a44/topic/5a27f17d6982903f1c8c6532</a></li>
<li><a href="http://xiezhaodong.me/2016/03/05/ThreadLocal源码分析解密/" target="_blank" rel="noopener">http://xiezhaodong.me/2016/03/05/ThreadLocal源码分析解密/</a></li>
<li><a href="http://blog.zhangjikai.com/2017/03/29/%E3%80%90Java-%E5%B9%B6%E5%8F%91%E3%80%91%E8%AF%A6%E8%A7%A3-ThreadLocal/" target="_blank" rel="noopener">http://blog.zhangjikai.com/2017/03/29/%E3%80%90Java-%E5%B9%B6%E5%8F%91%E3%80%91%E8%AF%A6%E8%A7%A3-ThreadLocal/</a></li>
<li><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/" target="_blank" rel="noopener">http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/</a></li>
</ul>

      
    </div>

    <div>
      
        
<div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/siteimages/wechat_gzh.jpg" alt="wxweven wechat" style="width: 200px; max-width: 100%;">
    <div>分享技术，分享生活，来吧，为了生活，扫码撩我！</div>
</div>


      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/siteimages/wechatpay.jpeg" alt="wxweven WeChat Pay">
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/siteimages/alipay.jpeg" alt="wxweven Alipay">
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/ThreadLocal/" rel="tag"># ThreadLocal</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/22/Java8对读写锁的改进：StampedLock/" rel="next" title="Java8对读写锁的改进：StampedLock">
                <i class="fa fa-chevron-left"></i> Java8对读写锁的改进：StampedLock
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/15/Mac下brew设置国内源/" rel="prev" title="Mac下brew设置国内源">
                Mac下brew设置国内源 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/siteimages/avatar.png" alt="wxweven">
          <p class="site-author-name" itemprop="name">wxweven</p>
           
              <p class="site-description motion-element" itemprop="description">分享技术 享受生活</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">44</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wxweven" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/wxweven" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-zhihu"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/1958118930" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/wxweven" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-douban"></i>
                  
                  豆瓣
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://coderq.com,一个面向程序员交流分享的新一代社区" title="码农圈" target="_blank">码农圈</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://wuchong.me" title="Jark's Blog" target="_blank">Jark's Blog</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://tool.lu, 各种工具" title="王大神的博客" target="_blank">王大神的博客</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadLocal概述"><span class="nav-text">1. ThreadLocal概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#举个栗子"><span class="nav-text">1.1. 举个栗子</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadLocal-的实现"><span class="nav-text">2. ThreadLocal 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal内部结构"><span class="nav-text">2.1. ThreadLocal内部结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal-API"><span class="nav-text">2.2. ThreadLocal API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-的-set-方法"><span class="nav-text">2.2.1. ThreadLocal 的 set 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal的get方法"><span class="nav-text">2.2.2. ThreadLocal的get方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal的remove方法"><span class="nav-text">2.2.3. ThreadLocal的remove方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#核心的ThreadLocalMap"><span class="nav-text">3. 核心的ThreadLocalMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash冲突处理"><span class="nav-text">3.1. Hash冲突处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocalMap-API"><span class="nav-text">3.2. ThreadLocalMap API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap构造函数"><span class="nav-text">3.2.1. ThreadLocalMap构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap的set方法"><span class="nav-text">3.2.2. ThreadLocalMap的set方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap的getEntry方法"><span class="nav-text">3.2.3. ThreadLocalMap的getEntry方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap的remove方法"><span class="nav-text">3.2.4. ThreadLocalMap的remove方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadLocal的内存泄露"><span class="nav-text">4. ThreadLocal的内存泄露</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄露原理分析"><span class="nav-text">4.1. 内存泄露原理分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄露问题解决"><span class="nav-text">4.2. 内存泄露问题解决</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap的清理"><span class="nav-text">4.2.1. ThreadLocalMap的清理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap-的-remove"><span class="nav-text">4.2.2. ThreadLocalMap 的 remove</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#expungeStaleEntry源码解析"><span class="nav-text">4.2.3. expungeStaleEntry源码解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap-的-set"><span class="nav-text">4.2.4. ThreadLocalMap 的 set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap的getEntry"><span class="nav-text">4.2.5. ThreadLocalMap的getEntry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存泄露问题小结"><span class="nav-text">4.2.6. 内存泄露问题小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#思考题"><span class="nav-text">5. 思考题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-text">6. 参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wxweven</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
  <div class="powered-by"></div>
  <span class="post-count">共103.4k字</span>
</div>






        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  

  





  

  

  

  

  

  

</body>
</html>
